<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <title>Vertices</title>
</head>

<body>
  <!-- <div id="arweaveContainer">
    <img src="img/arweave_logo.svg" alt="Arweave Logo" id="arweaveLogo" />
    <img src="img/UWE-Bristol-Logo-Banner.png" alt="Arweave Logo" id="arweaveLogo" /> 

  </div> -->
  <div id="tutorialContainer">
    <div id="tutorialText">Tap anywhere to create a Vertex</div>
  </div>
  <div id="floatingTextContainer">
    <div id="floatingText">
      <span id="title"> How to Interact and change artwork </span>
      <ul>
        <li>Tap ‘+’ button</li>
        <li>Tap anywhere on screen to add a vertice</li>
        <li>A line draws from the last vertice to yours</li>
        <li>Each audience interaction is stored on Arweave</li>
      </ul>
      <span id="title">Concept: Connection</span>
      <span>
        We are looking to foster more long-term and meaningful connections, to
        art, music and each other.
      </span>
      <span id="madeBy">
        Made by the Olta team: Paulo Matos, Alysson Santos & Terence Reilly
      </span>
    </div>
  </div>

  <div id="loadingOverlay">
    <div id="loadingDiv">
      <svg viewBox="0 0 100 100">
        <circle cx="50" cy="50" r="45" fill="none" stroke="#FFFFFF50" stroke-width="10" />
        <circle id="progress" cx="50" cy="50" r="45" fill="none" stroke="white" stroke-width="11"
          stroke-dasharray="0 283" stroke-linecap="round" />
      </svg>
    </div>
    <div id="popupMessage">
      <span id="loadingText"></span>
      <!-- Share button inside message div to be shown when interaction goes through -->
      <button class="floating__share" type="button" id="shareButton">
        SHARE
      </button>
    </div>
  </div>

  <div id="optionsSection">
    <button id="addVertexButton" class="animated">+</button>
    <button id="infoButton" class="camera-button">
      <img src="img/info_icon.svg" alt="Information" />
    </button>

    <!-- Camera buttons -->
    <div id="cameraButtonContainer">
      <button id="mainCameraButton" class="camera-button">
        <img id="cameraImage" src="img/front_icon.svg" alt="Camera" />
        <img id="backImage" class="hidden" src="img/back_icon.svg" alt="Back" />
      </button>
      <button id="cameraRestart" class="camera-button hidden">
        <img src="img/camera_restart.svg" alt="Restart Camera" />
      </button>
      <button id="cameraEffects" class="camera-button hidden">
        <img src="img/camera_effects.svg" alt="Effects" />
      </button>
      <button id="cameraRotation" class="camera-button hidden">
        <img src="img/camera_rotate.svg" alt="Rotation" />
      </button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://unpkg.com/vanilla-sharing"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"
    integrity="sha512-7tWCgq9tTYS/QkGVyKrtLpqAoMV9XIUxoou+sPUypsaZx56cYR/qio84fPK9EvJJtKvJEwt7vkn6je5UVzGevw=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- <script type="x-shader/x-vertex" id="vertexShader">
      varying vec3 WorldPosition;
      void main() {
      	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                   WorldPosition = worldPosition.xyz;
      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1 );
      }
    </script>

  <script type="x-shader/x-fragment" id="fragmentShader">
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      varying vec3 WorldPosition;
      void main() {
      	float h = normalize( WorldPosition + offset ).y;
      	gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
      }
    </script> -->

  <!-- NEW WAY OF UPDATING AND IMPORTING THREE.JS -->
  <!-- Import maps polyfill -->
  <!-- Remove this when import maps will be widely supported -->
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

  <script type="importmap">
      {
        "imports": {
          "three": "./build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

  <script type="module">
    import { Olta } from "./lib/olta.module.js";

    import * as THREE from "three";
    // import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    // import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    // import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    // import { HalftonePass } from "three/addons/postprocessing/HalftonePass.js";


    const olta = Olta();

    // ----------- Message Logic -----------
    let startTime;
    const loadingText = document.getElementById("loadingText");
    const loadingOverlay = document.getElementById("loadingOverlay");

    let currentMessage;
    let loading = false;

    let messages = [
      "You are contributing to a permanent work of art. Etched into digital stone on Arweave",
    ];
    // ------------ Share Logic ------------
    let snap = false;
    const shareButton = document.getElementById("shareButton");

    let scene, camera, renderer, controls;
    let vertices = [];
    let pendingVertices = [];
    let lastDraw = 0;
    let lines = [];
    let currentLine;
    let drawing = false;
    let drawIndex = 1;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    var rotationOn = true;
    var displayInfo = false;
    var displayMessage = false;
    var lineSpeed = 50; // 100 

    // ----- Options Panel -----
    const backImage = document.getElementById("backImage");
    const cameraImage = document.getElementById("cameraImage");
    const buttonAdd = document.getElementById("addVertexButton");
    const cameraEffects = document.getElementById("cameraEffects");
    const cameraRestart = document.getElementById("cameraRestart");
    const cameraRotation = document.getElementById("cameraRotation");
    const infoButton = document.getElementById("infoButton");
    const cameraButtonContainer = document.getElementById(
      "cameraButtonContainer"
    );
    const floatingTextContainer = document.getElementById(
      "floatingTextContainer"
    );
    const floatingText = document.getElementById("floatingText");
    const tutorialContainer = document.getElementById("tutorialContainer");

    // ----- Effects -----
    // var effectsOn = false;
    // var composer, renderPass, halftonePass;
    // var uniforms;
    // var afterimagePass;
    // var params = {
    //   shape: 4,
    //   radius: 1,
    //   rotateR: 40.23,
    //   rotateB: 44.63,
    //   rotateG: 41.31,
    //   scatter: 1,
    //   blending: 0.63,
    //   blendingMode: 1,
    //   greyscale: true,
    //   disable: false,
    // };
    // var sky1;
    // const postprocessing = {}; // new

    // Create sphere (loading indicator)
    let sphereVisible = false;
    const geometry = new THREE.SphereGeometry(200, 32, 32);
    const material = new THREE.MeshBasicMaterial({
      color: getRandomColorInt(),
      opacity: 0.5,
      transparent: true,
    });
    const sphere = new THREE.Mesh(geometry, material);

    let canAddVertice = false;

    init();
    animate();

    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color("#fefefe");

      // -loading-
      startTime = performance.now();

      // Create camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100000 // 100000
      );
      camera.position.z = 5000; // 2000

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // renderer.toneMapping = THREE.ReinhardToneMapping;

      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, 0);
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.25;

      // Camera settings for distance and rotation
      controls.minPolarAngle = Math.PI * 0.2;
      controls.maxPolarAngle = Math.PI * 0.2;
      controls.minDistance = -1000; //-1000
      controls.maxDistance = 10000; // 5000
      //controls.enablePan = false;

      // // SKYDOME - BG GRADIENT
      // var vertexShader = document.getElementById("vertexShader").textContent;
      // var fragmentShader =
      //   document.getElementById("fragmentShader").textContent;
      // var uniforms = {
      //   topColor: { value: new THREE.Color("white") },
      //   bottomColor: { value: new THREE.Color("#777777") },
      //   offset: { value: 4000 },
      //   exponent: { value: 1 },
      // };

      // //uniforms.topColor.value.copy( hemiLight.color ); grey out
      // // scene.fog.color.copy(uniforms.bottomColor.value);
      // var skyGeo = new THREE.SphereGeometry(2000, 32, 32);
      // var skyMat = new THREE.ShaderMaterial({
      //   vertexShader: vertexShader,
      //   fragmentShader: fragmentShader,
      //   uniforms: uniforms,
      //   side: THREE.BackSide,
      // });

      // sky1 = new THREE.Mesh(skyGeo, skyMat);

      // // Delay postprocess to ensure correct dimensions
      // setTimeout(setupPostProcessing, 100);

      olta.onUpdate(() => {
        pendingVertices = olta.getAll("vertices");

        // only update the vertices if there are new vertices
        if (!pendingVertices || pendingVertices.length < 1) {
          return;
        }

        if (drawIndex <= 1) {
          // Code to add a first vertice on the start of the vertices array
          // pendingVertices.unshift({
          //   x: 0,
          //   y: 0,
          //   z: 0,
          //   lineColor: getRandomColorInt(),
          //   vertexColor: getRandomColorInt(),
          // });

          pendingVertices.forEach((vertex) => {
            addVertex(vertex);
          });
          // Code to center the camera pivot on the first vertice instead of origin (0,0,0)
          // controls.target.set(
          //   pendingVertices[0].x,
          //   pendingVertices[0].y,
          //   pendingVertices[0].z
          // );
        } else {
          for (let i = lastDraw; i < pendingVertices.length; i++) {
            addVertex(pendingVertices[i]);
          }
        }

        lastDraw = pendingVertices.length - 1;
        // reset pending vertices
        pendingVertices = [];
      });

      // Draw lines between vertices
      drawLines();
    }

    // function setupPostProcessing() {
    //   // post-processing
    //   composer = new EffectComposer(renderer);
    //   renderPass = new RenderPass(scene, camera);
    //   halftonePass = new HalftonePass(
    //     window.innerWidth,
    //     window.innerHeight,
    //     params
    //   );

    //   composer.addPass(renderPass);
    //   composer.addPass(halftonePass);
    // }

    function addVertex(vertice) {
      vertices.push(vertice);

      // Will change the vertex color to use the _creator property (wallet)
      // let colorVertex = intToHexColor(vertice.vertexColor);
      let colorVertex = walletToColor(vertice._creator);

      // Create a visible point for the vertex
      const pointGeometry = new THREE.SphereGeometry(20, 32, 32);
      const pointMaterial = new THREE.MeshBasicMaterial({
        color: colorVertex,
        side: THREE.DoubleSide, // double sided sphere
      });
      const point = new THREE.Mesh(pointGeometry, pointMaterial);
      point.position.set(vertice.x, vertice.y, vertice.z);
      scene.add(point);
    }

    function drawLines() {
      if (drawing) return;
      if (drawIndex < vertices.length) {
        let currentVertice = vertices[drawIndex - 1];
        let currentVertex = new THREE.Vector3(
          currentVertice.x,
          currentVertice.y,
          currentVertice.z
        );
        let nextVertice = vertices[drawIndex];
        let nextVertex = new THREE.Vector3(
          nextVertice.x,
          nextVertice.y,
          nextVertice.z
        );
        let currentLineColor = intToHexColor(currentVertice.lineColor);

        const material = new THREE.MeshBasicMaterial({
          color: currentLineColor,
        });

        // Number of segments to draw the line
        var segments = lineSpeed;
        const points = [currentVertex, nextVertex];

        currentLine = {
          points,
          material,
          lineThickness: 5,
          segments,
          step: 2, // Number of segments to add per frame
          currentSegment: 0,
          drawnPoints: [currentVertex], // Start with the first point
        };

        lines.push(currentLine);
        drawing = true;
      }
      if (drawIndex >= vertices.length - 1) {
        lineSpeed = 100;
      }
    }

    // Fix for iPhone
    buttonAdd.style.display = "flex";
    buttonAdd.style.alignItems = "center";
    buttonAdd.style.justifyContent = "center";

    function animate() {
      if (canAddVertice) {
        document.body.style.cursor = "copy";
        buttonAdd.innerText = "✘";
        controls.autoRotate = false;
        collapseCameraOptions("close");
        tutorialContainer.style.display = "flex";
      } else {
        document.body.style.cursor = "auto";
        buttonAdd.innerText = "+";
        controls.autoRotate = rotationOn;
        tutorialContainer.style.display = "none";
      }

      requestAnimationFrame(animate);
      renderer.render(scene, camera);







      // ----- Share Moment Logic -----
      if (snap) {
        // Olta.js function to create a base64 screenshot
        olta
          .capture3d(renderer)
          .then((screenshot) => olta.showShareDialog(screenshot))
          .catch((error) => console.log("error", error));
        snap = false;
      }

      // ----- Camera Buttons -----
      if (rotationOn) {
        cameraRotation.style.backgroundColor = "#555555";
      } else {
        cameraRotation.style.backgroundColor = "#54545482";
      }
      // if (effectsOn) {
      //   cameraEffects.style.backgroundColor = "#555555";
      // } else {
      //   cameraEffects.style.backgroundColor = "#54545482";
      // }

      if (currentLine && drawing) {
        const {
          points,
          material,
          lineThickness,
          segments,
          step,
          currentSegment,
          drawnPoints,
        } = currentLine;

        const startPoint = points[0];
        const endPoint = points[1];

        if (currentSegment < segments) {
          const t = (currentSegment + step) / segments;
          const interpolatedPoint = new THREE.Vector3().lerpVectors(
            startPoint,
            endPoint,
            t
          );
          drawnPoints.push(interpolatedPoint);

          const geometry = new THREE.TubeGeometry(
            new THREE.CatmullRomCurve3(drawnPoints),
            drawnPoints.length - 1,
            lineThickness,
            8,
            false
          );

          const lineMesh = new THREE.Mesh(geometry, material);

          if (currentLine.mesh) {
            scene.remove(currentLine.mesh);
          }

          currentLine.mesh = lineMesh;
          scene.add(lineMesh);

          currentLine.currentSegment += step;
        }

        if (currentSegment >= segments) {
          // ------ Sphere Indicator Logic ------
          if (sphereVisible) {
            const lastVertex =
              currentLine.points[currentLine.points.length - 1];
            const distanceToSphere = lastVertex.distanceTo(sphere.position);
            if (distanceToSphere < 20) {
              // Line reached the sphere, remove it
              sphereVisible = false;
              scene.remove(sphere);

              // ----------- Message Logic -----------
              displayMessageContainer();

              generateRandomMessage().then((message) => {
                currentMessage = message;
                loadingText.innerHTML = currentMessage;
              });
              // ---------------------------------------
            }
          }

          currentLine = null;
          drawing = false;
          drawIndex++;
        }
      } else if (!drawing) {
        drawLines();
      }

      controls.update();

      // render
      const elapsed = (performance.now() - startTime) / 1000;

      renderer.render(scene, camera);

      // delay post processing
      // if (composer && effectsOn) {
      //   composer.render();
      // } else {
      //   renderer.render(scene, camera);
      // }
    }

    window.addEventListener("resize", onWindowResize);
    renderer.domElement.addEventListener("click", onClick);
    renderer.domElement.addEventListener("touchstart", onClick);

    loadingOverlay.addEventListener("click", closeMessage);
    loadingOverlay.addEventListener("touchstart", closeMessage);

    // if (composer) composer.setSize(window.innerWidth, window.innerHeight);

    // Flag to control which event was fired
    let isTouchEvent = false;

    buttonAdd.addEventListener("click", (event) => {
      closeInfoPanel();

      if (isTouchEvent) {
        isTouchEvent = false; // Reset the flag
        return; // Ignore this event because touchstart was fired
      }

      canAddVertice = !canAddVertice;
    });

    // -- Add Button --
    buttonAdd.addEventListener(
      "touchstart",
      (event) => {
        isTouchEvent = true; // Set the flag to indicate a touch event was fired
        canAddVertice = !canAddVertice;
      },
      { passive: true }
    );

    // ----- Share -----

    shareButton.addEventListener("click", async () => {
      snap = true;
    });

    shareButton.addEventListener("touchstart", async () => {
      snap = true;
    });

    // ----- Camera Mode Buttons -----
    document
      .getElementById("mainCameraButton")
      .addEventListener("click", () => {
        collapseCameraOptions();
        closeInfoPanel();
      });

    cameraRotation.addEventListener("click", () => {
      rotationOn = !rotationOn;
    });

    cameraRestart.addEventListener("click", () => {
      controls.reset();
    });

    infoButton.addEventListener("click", () => {
      displayInfoPanel();
      collapseCameraOptions("close");
    });

    // cameraEffects.addEventListener("click", () => {
    //   effectsOn = !effectsOn;
    //   if (!effectsOn) {
    //     scene.remove(sky1);
    //   } else {
    //     scene.add(sky1);
    //   }
    // });

    function displayInfoPanel() {
      if (!displayInfo) {
        floatingText.style.opacity = 0;
        floatingText.style.display = "flex";

        setTimeout(() => {
          floatingText.style.opacity = 1;
          displayInfo = true;
        }, 200);
      } else {
        closeInfoPanel();
      }
    }

    function closeInfoPanel() {
      floatingText.style.opacity = 0;

      setTimeout(() => {
        floatingText.style.display = "none";
        floatingText.style.opacity = 1;
        displayInfo = false;
      }, 500);
    }

    function displayMessageContainer() {
      if (!displayMessage) {
        loadingOverlay.style.opacity = 0;
        loadingOverlay.style.display = "block";

        setTimeout(() => {
          loadingOverlay.style.opacity = 1;
          displayMessage = true;
        }, 200);
      } else {
        closeMessage();
      }
    }

    function closeMessage() {
      loadingOverlay.style.opacity = 0;

      setTimeout(() => {
        loadingOverlay.style.display = "none";
        loadingOverlay.style.opacity = 1;
        displayMessage = false;
      }, 500);
    }

    function collapseCameraOptions(action = null) {
      if (action === "close") {
        cameraRotation.classList.add("hidden");
        cameraRestart.classList.add("hidden");
        cameraEffects.classList.add("hidden");

        backImage.classList.remove("fade-in");
        cameraImage.classList.add("fade-in");
        cameraButtonContainer.style.backgroundColor = "inherit";
        cameraButtonContainer.style.borderRadius = "inherit";
        cameraButtonContainer.style.height = "inherit";
        cameraButtonContainer.style.paddingLeft = "inherit";
        setTimeout(() => {
          backImage.classList.add("hidden");
          cameraImage.classList.remove("hidden");
        }, 200);
        return; // exit the function
      } else if (action === "open") {
        cameraRotation.classList.remove("hidden");
        cameraRestart.classList.remove("hidden");
        cameraEffects.classList.remove("hidden");
      } else {
        cameraRotation.classList.toggle("hidden");
        cameraRestart.classList.toggle("hidden");
        cameraEffects.classList.toggle("hidden");
      }

      if (cameraImage.classList.contains("hidden")) {
        cameraImage.classList.remove("fade-out");
        backImage.classList.remove("fade-in");
        backImage.classList.add("fade-out");
        cameraImage.classList.add("fade-in");
        cameraButtonContainer.style.backgroundColor = "inherit";
        cameraButtonContainer.style.borderRadius = "inherit";
        cameraButtonContainer.style.height = "inherit";
        cameraButtonContainer.style.paddingLeft = "inherit";
        setTimeout(() => {
          backImage.classList.add("hidden");
          cameraImage.classList.remove("hidden");
        }, 200);
      } else {
        backImage.classList.remove("fade-out");
        cameraImage.classList.remove("fade-in");
        cameraImage.classList.add("fade-out");
        backImage.classList.add("fade-in");
        cameraButtonContainer.style.backgroundColor = "#44444450";
        cameraButtonContainer.style.borderRadius = "50px";
        cameraButtonContainer.style.height = "55px";
        cameraButtonContainer.style.paddingLeft = "10px";
        setTimeout(() => {
          cameraImage.classList.add("hidden");
          backImage.classList.remove("hidden");
        }, 200);
      }
    }

    function handleIn() {
      if (!canAddVertice) {
        buttonAdd.style.backgroundColor = "#44be44";
      } else {
        buttonAdd.style.backgroundColor = " #44be44";
      }
    }

    function handleOut() {
      if (!canAddVertice) {
        buttonAdd.style.backgroundColor = "#55ee55";
      } else {
        buttonAdd.style.backgroundColor = "#55ee55";
      }
    }

    buttonAdd.addEventListener("mouseenter", handleIn);
    buttonAdd.addEventListener("mouseleave", handleOut);
    buttonAdd.addEventListener("touchstart", handleIn);
    buttonAdd.addEventListener("touchend", handleOut);
    // ----------------

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Update the postprocessing passes on window resize
      // if (composer && halftonePass) {
      //   composer.setSize(window.innerWidth, window.innerHeight);
      //   halftonePass.setSize(window.innerWidth, window.innerHeight);
      // }
    }

    function onClick(event) {
      buttonAdd.classList.remove("animated");

      collapseCameraOptions("close");

      let clientX, clientY;

      if (event.type === "touchstart") {
        isTouchEvent = true;
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
      } else {
        isTouchEvent = false;
        clientX = event.clientX;
        clientY = event.clientY;
      }

      if (canAddVertice) {
        if (!loading) {
          // Calculate mouse position in normalized device coordinates
          // (-1 to +1) for both components
          mouse.x = (clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(clientY / window.innerHeight) * 2 + 1;

          // Update the raycaster with the camera and mouse position
          raycaster.setFromCamera(mouse, camera);

          // Define the range for the distance from the camera
          const minDistance = 120;
          const maxDistance = 800;

          // Find intersection with the near plane
          const nearPoint = new THREE.Vector3();
          raycaster.ray.at(camera.near, nearPoint);

          // Find intersection with the far plane
          const farPoint = new THREE.Vector3();
          raycaster.ray.at(camera.far, farPoint);

          // Interpolate between near and far points based on a random value
          const randomT =
            minDistance + Math.random() * (maxDistance - minDistance);

          // What is clickpoint ?
          // clickPoint is a point created between two 3D points 
          // (nearPoint and farPoint) based on some random factor (randomT / camera.far).
          // The code then checks if the clickPoint is behind the camera by 
          // calculating the direction from the camera to the point.
          // If the point is too close to the camera, it moves the clickPoint 
          // forward by a minimum distance so that it's always in front of the camera.

          // What is Vector3 ?
          // THREE.Vector3(): This is part of a library called Three.js, 
          // which is used for working with 3D graphics.
          // new THREE.Vector3(): This creates a new 3D vector. Initially, 
          // it will have values x = 0, y = 0, and z = 0.

          // What is lerp ?
          // But here we create clickPoint Using lerpVectors. 
          // lerp stands for "linear interpolation." It’s a 
          // way to find a point between two other points based on a percentage.
          // nearPoint and farPoint are two 3D points 
          // They represent the closest and farthest points in space along a line, 
          // such as a line from the camera to an object.
          const clickPoint = new THREE.Vector3().lerpVectors(
            nearPoint,
            farPoint,
            randomT / camera.far
          );

          // Ensure the vertex is not behind the camera
          const cameraDirection = new THREE.Vector3()
            .subVectors(clickPoint, camera.position)
            .normalize();
          clickPoint.add(cameraDirection.multiplyScalar(minDistance));

          // Here we take the coordinates of a click 
          // (clickPoint.x, clickPoint.y, clickPoint.z), 
          // round them down to whole numbers, and use
          // those rounded values to create a new object called newVertice.

          // In addition to storing the x, y, and z coordinates, 
          // the new vertex also has two random colors (lineColor and 
          // vertexColor), generated by the getRandomColorInt() function.
          // This newVertice object is used to draw & place
          // points in a 3D space.
          let limitedX, limitedY, limitedZ;
          limitedX = Math.floor(clickPoint.x);
          limitedY = Math.floor(clickPoint.y);
          limitedZ = Math.floor(clickPoint.z);

          let newVertice = {
            x: limitedX,
            y: limitedY,
            z: limitedZ,
            lineColor: getRandomColorInt(),
            vertexColor: getRandomColorInt(),
          };

          // Create and animate wireframe sphere
          const sphere = createWireframeSphere(clickPoint);
          animatePulsatingSphere(sphere);

          // Speed up the line
          lineSpeed = 2;

          olta.create("vertices", newVertice);

          // Reseting button to default state
          canAddVertice = false;
          buttonAdd.style.backgroundColor = "#55ee55";

          if (rotationOn) {
            rotationOn = false;
            setTimeout(() => {
              rotationOn = true;
            }, 12000);
          }
        }
      }

      // ----- Welcome text logic -----
      floatingText.style.opacity = 0;

      setTimeout(() => {
        floatingText.style.display = "none";
        floatingText.style.opacity = 1;
        displayInfo = false;
      }, 500);
    }

    // Utils
    // Generate a random integer in the range [0x000000, 0xEEEEEE]
    // From 0 to 15658734 in decimal
    function getRandomColorInt() {
      return Math.floor(Math.random() * 0xeeeeee);
    }

    // Convert an integer to a hex color string
    function intToHexColor(colorInt) {
      let hexColor = colorInt.toString(16);
      return `#${hexColor.padStart(6, "0")}`;
    }

    // Convert a wallet address into a color
    function walletToColor(wallet) {
      // Hash the wallet using a simple hash function
      let hash = 0;
      for (let i = 0; i < wallet.length; i++) {
        hash = (hash << 5) - hash + wallet.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      // Ensure the hash is non-negative
      hash = Math.abs(hash);

      // Map the hash value to the range 0 to 15658734
      let integerColor = hash % (15658734 + 1);

      let finalColor = intToHexColor(integerColor);

      return finalColor;
    }

    // ----------- Sphere Indicator -----------

    function createWireframeSphere(position) {
      sphereVisible = true;

      sphere.position.copy(position);
      scene.add(sphere);
      return sphere;
    }

    function animatePulsatingSphere(sphere) {
      const scaleDelta = 0.0024; // Previous: 0.008
      let increasing = true;

      function animate() {
        requestAnimationFrame(animate);
        if (increasing) {
          sphere.scale.addScalar(scaleDelta);
          if (sphere.scale.x >= 2) {
            increasing = false;
          }
        } else {
          sphere.scale.subScalar(scaleDelta);
          if (sphere.scale.x <= 1.5) {
            increasing = true;
          }
        }
      }

      animate();
    }

    // ----------- Function for Message Logic -----------
    async function generateRandomMessage() {
      let randomIndex = Math.floor(Math.random() * messages.length);
      let finalMessage = messages[randomIndex];
      return finalMessage;
    }
  </script>
</body>

</html>